- 没有隐式控制流，没有隐式内存分配，没有预处理器，没有宏
- 如果 zig 代码看起来不像在调用一个函数，那么它就不是

- Zig 将所有的控制流完全用语言关键字和函数调用来表达

- 四种构建模式：

  - debug
  - release safe
  - release fast
  - release small

- 堆栈跟踪

- 裸金属 ？

- 启用安全检查的构建模式

- 将未定义作为一个利器，既可以预防 bug，又可以提升性能

  - 参考实现使用 LLVM 作为后端进行最先进的优化
  - 链接时优化在 zig 中自动达成
  - 对交叉编译的一流支持，对于原生构建目标、高级 CPU 特性可以被启用
  - 未定义行为
  - Zig 直接暴露了 SIMD 向量类型，编写跨平台的向量化代码更容易

- 顺序无关的顶层声明

  - 全局变量等顶层声明与顺序无关，并进行惰性分析。全局变量的初始值在编译时进行求值

- 可选类型代替空指针

  - 不加修饰的 Zig 指针不可为空
  - ?可选类型
  - orelse
  - if
  - while

- 手动内存管理
  - 用Zig编写的库可以用在任何地方：
    - 桌面程序
    - 低延迟服务器
    - 操作系统内核
    - 嵌入式设备
    - 实时软件
    - 浏览器或者其他使用WebAssembly作为插件的程序
    - 通过C ABI给其他语言调用
  - Zig程序员必须自己管理自己的内存，必须处理内存分配失败
  - 需要分配内存的函数都会接受一个分配器参数。因此Zig标准库甚至可以用于裸金属的目标
  - defer
  - errdefer

- 错误是值，不可忽略
  - catch
  - 关键词try 是 catch |err| return err的简写
    - 错误返回跟踪
    - 堆栈跟踪
  - 在错误值上使用switch关键词可以用于确保所有可能的错误都被处理
  - unreachable用于断言不会发生错误

- 在所有目标上启用堆栈跟踪

- 泛型数据结构与函数
  - 类型和值必须在编译期已知
  - 泛型数据结构简单来说就是一个函数返回一个类型

- 编译期反射和编译期代码执行
  - @typeInfo内置函数可以用于提供编译期反射

- zig标准库使用这种技术来实现格式化打印，zig的格式化打印完全是在zig中实现的

- zig还可以在编译期对函数和代码块求值

- 无需FFI/bindings的C库集成
  - @cimport可以直接导入类型、变量、函数和简单的宏。
  - 甚至能将C内联函数翻译为Zig函数

- Zig也是C的编译器
  - zig与libc一起发布，所以可以使用zig作为c的编译器

- 导出函数、变量和类型供C代码使用

- 交叉编译的一流支持

- Zig构建系统
  - zig init-exe

- 使用异步函数进行并发
  - 该功能不依赖宿主操作系统，甚至不依赖堆分配的内存，可用于裸金属目标
  - zig自动推导函数是否为异步，并允许在非异步函数上进行async/await，这意味着 Zig 库对阻塞与异步 I/O 是不可知的
  - 实现了一个事件循环